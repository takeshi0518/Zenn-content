---
title: 'MVCからNext.jsへ -同じブログアプリを作り直して分かった、技術選択の理由'
emoji: '🔄'
type: 'tech' # tech: 技術記事 / idea: アイデア
topics: ['nextjs', 'react', 'mvc', 'フロントエンド']
published: false
---

## はじめに

### この記事を書いた理由

僕は現在、Next.js を使ってポートフォリオアプリケーションを開発しています。しかし、ある時ふと気づきました。  
**「なぜ Next.js を使っているのか、自分の言葉で説明できない」**  
チュートリアルをこなし、公式ドキュメントを読み、アプリを作る。基本的はことはある程度できるようになりましたが、**「なぜこの技術が必要なのか」**という本質を理解していませんでした。

### Web アプリケーションの変遷との出会い

学習を進める中で、Web アプリケーションの変遷について調べる機会がありました。

https://speakerdeck.com/recruitengineers/react-2023

こちらの資料を読んだ理由は React の基礎を学びたかったからですが、それよりも技術の移り変わりについて非常に丁寧に書いてくださっており、そちらにも興味が湧きました。  
そして以下の流れが見えてきました。

- 2000 年代の**MVC アーキテクチャ**(サーバーサイドレンダリング)
- 2010 年代の**SPA**(シングルページアプリケーション)
- 現在の**Next.js**(ハイブリッドアプローチ)

この流れを知った時、ある仮説が浮かびました。

### 仮説: 技術は問題や課題解決の結果として生まれる

**「流行っている技術、新しい技術は、何かの問題を解決した結果として誕生し、普及したのではないか？」**

もしそうなら

- MVC には何か**解決できない問題**が生まれた
- SPA がそれを解決したが、また**別の問題**が生まれた
- Next.js はその問題を解決するために生まれた

この仮説を検証するために、僕は実際に手を動かすことにしました。
僕と同じ初学者、Next.js を何となく使っている、技術選択の理由を知りたい方の参考になれば幸いです。

:::message
記事の内容に誤りや改善点があれば、コメントで教えていただけると嬉しいです。
:::

## 比較検証のアプリケーション紹介

### MVC ブログアプリの概要

まず、2000 年代の web アプリケーションを体験するために、MVC アーキテクチャでブログアプリを作成しました。  
このアプリケーションは、記事の投稿・閲覧・編集・削除ができるシンプルなブログです。あえて jQuery や EJS といった古い技術を使うことで、当時の開発スタイルを再現しています。

https://github.com/takeshi0518/blog-mvc

![MVCブログアプリのスクリーンショット](/images/blog_mvc-screen-shot.png)

#### 技術スタック

- バックエンド: Node.js (Express)
- テンプレートエンジン: EJS
- データベース: PostgreSQL
- フロントエンド: jQuery

#### 実装した機能

- 記事の CRUD 操作(作成・閲覧・編集・削除)
- コメント機能

#### アーキテクチャの特徴

MVC アーキテクチャ最大の特徴は**関心の分離(Separation of Concerns)**です。

- Model: データとビジネスロジック
- View: 表示(UI)
- Controller: 制御(リクエストの処理と Model と View の橋渡し)

この３つの役割を分離することで、保守性・再利用性・拡張性・開発効率を高めることができます。

#### 実際のコード

例えば、記事一覧を表示する処理は以下のように分離されています。

**Model (Post.js)** - データ取得に専念

```javascript
  static async findAll() {
    try {
      const result = await pool.query(
        'SELECT * FROM posts ORDER BY created_at DESC'
      );
      return result.rows;
    } catch (err) {
      throw err;
    }
  }
```

**Controller postsController.js()** - 制御に専念

```javascript
exports.index = async (req, res) => {
  const posts = await Post.findAll(); // Modelに「データくれ」と依頼
  res.render('posts/index', {
    // Viewに「これ表示して」と渡す
    title: '記事一覧',
    posts: posts,
  });
};
```

**View (index.ejs)** - 表示に専念

```html
<% posts.forEach((post) => { %>
<article class="post-card">
  <h2><a href="/posts/<%= post.id %>"><%= post.title %></a></h2>
  <p><%= post.content.substring(0, 100) %>...</p>
</article>
<% }); %>
```

それぞれが独立しているため、例えば

- データベースを変更したい → **Model だけ修正**
- 表示デザインを変更したい → **View だけ修正**
- ページネーションを追加したい → **Controller だけ修正**

このように**影響範囲を限定できる**のが MVC の強みです。

1. Next.js での再実装

- Next.js 版の設計方針
- 同じ機能をどう実装したか
- 主要な実装の違い

5. 比較検証 3 つの観点

**5-1. ユーザー体験の観点**

- 初回ロード速度
- 画面遷移の体験
- SEO 対応

**5-2. 開発体験の観点**

- ルーティングの実装方法
- UI ロジックの結合度
- インタラクティブな機能の実装のしやすさ
- 型安全性と DX

**5-3. アーキテクチャの観点**

- サーバとクライアントの責務分担
- 状態管理の違い
- コンポーネント設計の考え方

6. なぜ Next.js を使うのか-僕なりの答え

- MVC が廃れていない理由
- それでも Next.js が選ばれる理由
- 適材適所の技術選択

7. まとめ

- 検証を通して得られた学び

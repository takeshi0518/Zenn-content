---
title: 'MVCからNext.jsへ -同じブログアプリを作り直して分かった、技術選択の理由'
emoji: '🔄'
type: 'tech' # tech: 技術記事 / idea: アイデア
topics: ['nextjs', 'react', 'mvc', 'フロントエンド']
published: false
---

## はじめに

### この記事を書いた理由

僕は現在、Next.js を使ってポートフォリオアプリケーションを開発しています。しかし、ある時ふと気づきました。  
**「なぜ Next.js を使っているのか、自分の言葉で説明できない」**  
チュートリアルをこなし、公式ドキュメントを読み、アプリを作る。基本的はことはある程度できるようになりましたが、**「なぜこの技術が必要なのか」**という本質を理解していませんでした。

### Web アプリケーションの変遷との出会い

学習を進める中で、Web アプリケーションの変遷について調べる機会がありました。

https://speakerdeck.com/recruitengineers/react-2023

こちらの資料を読んだ理由は React の基礎を学びたかったからですが、それよりも技術の移り変わりについて非常に丁寧に書いてくださっており、そちらにも興味が湧きました。  
そして以下の流れが見えてきました。

- 2000 年代の**MVC アーキテクチャ**(サーバーサイドレンダリング)
- 2010 年代の**SPA**(シングルページアプリケーション)
- 現在の**Next.js**(ハイブリッドアプローチ)

この流れを知った時、ある仮説が浮かびました。

### 仮説: 技術は問題や課題解決の結果として生まれる

**「流行っている技術、新しい技術は、何かの問題を解決した結果として誕生し、普及したのではないか？」**

もしそうなら

- MVC には何か**解決できない問題**が生まれた
- SPA がそれを解決したが、また**別の問題**が生まれた
- Next.js はその問題を解決するために生まれた

この仮説を検証するために、僕は実際に手を動かすことにしました。
僕と同じ初学者、Next.js を何となく使っている、技術選択の理由を知りたい方の参考になれば幸いです。

:::message
記事の内容に誤りや改善点があれば、コメントで教えていただけると嬉しいです。
:::

## 比較検証のアプリケーション紹介

### MVC ブログアプリの概要

まず、2000 年代の web アプリケーションを体験するために、MVC アーキテクチャでブログアプリを作成しました。  
このアプリケーションは、記事の投稿・閲覧・編集・削除ができるシンプルなブログです。あえて jQuery や EJS といった古い技術を使うことで、当時の開発スタイルを再現しています。

https://github.com/takeshi0518/blog-mvc

![MVCブログアプリのスクリーンショット](/images/blog_mvc-screen-shot.png)

#### 技術スタック

- バックエンド: Node.js (Express)
- テンプレートエンジン: EJS
- データベース: PostgreSQL
- フロントエンド: jQuery

#### 実装した機能

- 記事の CRUD 操作(作成・閲覧・編集・削除)

#### アーキテクチャの特徴

MVC アーキテクチャ最大の特徴は**関心の分離(Separation of Concerns)**です。

- Model: データとビジネスロジック
- View: 表示(UI)
- Controller: 制御(リクエストの処理と Model と View の橋渡し)

この３つの役割を分離することで、保守性・再利用性・拡張性・開発効率を高めることができます。

#### 実際のコード

例えば、記事一覧を表示する処理は以下のように分離されています。

**Model (Post.js)** - データ取得に専念

```javascript
  static async findAll() {
    try {
      const result = await pool.query(
        'SELECT * FROM posts ORDER BY created_at DESC'
      );
      return result.rows;
    } catch (err) {
      throw err;
    }
  }
```

**Controller postsController.js()** - 制御に専念

```javascript
exports.index = async (req, res) => {
  const posts = await Post.findAll(); // Modelに「データくれ」と依頼
  res.render('posts/index', {
    // Viewに「これ表示して」と渡す
    title: '記事一覧',
    posts: posts,
  });
};
```

**View (index.ejs)** - 表示に専念

```html
<% posts.forEach((post) => { %>
<article class="post-card">
  <h2><a href="/posts/<%= post.id %>"><%= post.title %></a></h2>
  <p><%= post.content.substring(0, 100) %>...</p>
</article>
<% }); %>
```

それぞれが独立しているため、例えば

- データベースを変更したい → **Model だけ修正**
- 表示デザインを変更したい → **View だけ修正**
- ページネーションを追加したい → **Controller だけ修正**

このように**影響範囲を限定できる**のが MVC の強みです。

### MVC アーキテクチャの課題

MVC は保守性・拡張性に優れたアーキテクチャですが、モダンな Web アプリケーションに求められる要件を満たすには限界がありました。

#### 1. インタラクティブな操作が困難

例えば、「削除ボタンを押した瞬間、即座に記事がリストから消える」といった**楽観的 UI**を実装しようとすると

```html
<form action="/posts/<%= post.id %>?_method=DELETE" method="POST">
  <button type="submit">削除</button>
</form>
```

現状の MVC では**悲観的 UI**

1. ボタンを押す
2. サーバーに POST リクエスト
3. サーバーが DB 変更後、HTML 全体を再生成
4. ページ全体がリロード
5. やっと記事が消える

jQuery で Ajax を使えば部分的な更新も可能ですが、 DOM 操作が複雑になり、バグの温床になります。
EJS などのテンプレートエンジンは**状態を持てない**ため、クライアント側でのデータ管理が困難です。

#### 2. フロントエンド/バックエンドの分離による課題

さらに、当時の開発では**バックエンドとフロントエンドが完全に分離**されていました。

**バックエンド(サーバー)** EJS で HTML 構造を生成

```html
<article class="post-card">
  <h2><%= post.title %></h2>
</article>
```

**フロントエンド(ブラウザ)** jQuery で DOM 操作

```javascript
$('.post-card').fadeOut();
```

この分離により、おそらく以下のような課題があったと考えられます

- HTML のクラス名やレイアウト変更のたび、バックエンド/フロントエンド間でコミュニケーションが必要
- セレクタの不一致によるバグが発生しやすい
- UI とロジックが別ファイルで管理され、保守が困難

一方現代の React などの**宣言的 UI**では

```jsx
function PostCard({ post, onDelete }) {
  return (
    <article>
      <h2>{post.title}</h2>
      <button onClick={() => onDelete(post.id)}>削除</button>
    </article>
  );
}
```

UI とロジックが同じコンポーネント内に存在するため、変更の影響範囲が明確で保守性が向上します。

#### 3. ページ全体のリロード

MVC では、画面遷移のたびに**ページ全体がリロード**されます。

例えば、記事一覧から詳細画面へ移動する場合

```html
<a href="/posts/<%= post.id %>"><%= post.title %></a>
```

この遷移で起こること

1. サーバーにリクエスト
2. **ヘッダー・フッター・ナビゲーションを含む全ての HTML**を再生成
3. ブラウザが全ての HTML を再描画
4. CSS や JavaScript も再読み込み

**問題点**

- 画面のチラつき（一瞬白くなる）
- 変わらない部分（ヘッダー/フッター）も毎回再描画
- 不要な通信とレンダリングコストが発生

**モダンなフレームワーク(React/Next.js)では**

- 変更された部分だけ再レンダリング
- ヘッダー・フッターはそのまま維持
- スムーズな画面遷移（チラつきなし）
- 最小限の通信で高速表示

この違いが、ユーザー体験の向上に直結します。

## SPA の登場とその課題

### SPA がもたらした革新

2010 年代、React・Vue・Angular などの登場により、**SPA(Single Page Application)**が主流になりました。  
SPA は、MVC アーキテクチャの課題を以下のように解決しました

### 1. クライアント側での状態管理

```jsx
//Reactの例
const [posts, setPosts] = useState([]);

const handleDelete = (id) => {
  setPosts(posts.filter((post) => post.id !== id)); //即座にUI更新
  api.delete(`/posts/${id}`); //バックグラウンドでAPI呼び出し
};
```

- 楽観的 UI が簡単に実装できる
- ページリロード不要
- 状態をブラウザ上で管理

#### 2. 部分的な再レンダリング

```jsx
function PostList({ posts }) {
  return (
    <>
      {/*変更なし→再レンダリングされない*/}
      {/*ここだけ更新*/}
      {/*変更なし→再レンダリングされない*/}
    </>
  );
}
```

- 変更部分だけ更新
- スムーズな画面遷移
- チラつきなし

#### 3. 宣言的 UI

1. Next.js での再実装

- Next.js 版の設計方針
- 同じ機能をどう実装したか
- 主要な実装の違い

5. 比較検証 3 つの観点

**5-1. ユーザー体験の観点**

- 初回ロード速度
- 画面遷移の体験
- SEO 対応

**5-2. 開発体験の観点**

- ルーティングの実装方法
- UI ロジックの結合度
- インタラクティブな機能の実装のしやすさ
- 型安全性と DX

**5-3. アーキテクチャの観点**

- サーバとクライアントの責務分担
- 状態管理の違い
- コンポーネント設計の考え方

6. なぜ Next.js を使うのか-僕なりの答え

- MVC が廃れていない理由
- それでも Next.js が選ばれる理由
- 適材適所の技術選択

7. まとめ

- 検証を通して得られた学び

---
title: 'MVCからNext.jsへ -同じブログアプリを作り直して分かった、技術選択の理由'
emoji: '🔄'
type: 'tech' # tech: 技術記事 / idea: アイデア
topics: ['nextjs', 'react', 'mvc', 'フロントエンド']
published: false
---

## 1. はじめに

### この記事を書いた理由

僕は現在、Next.js を使ってポートフォリオアプリケーションを開発しています。しかし、ある時ふと気づきました。  
**「なぜ Next.js を使っているのか、自分の言葉で説明できない」**  
チュートリアルをこなし、公式ドキュメントを読み、アプリを作る。基本的はことはある程度できるようになりましたが、**「なぜこの技術が必要なのか」**という本質を理解していませんでした。
表面的な使い方だけではなく、**技術の本質を理解したい**。そう思った僕は Web アプリケーションの歴史を調べ始めました。

### Web アプリケーションの変遷との出会い

学習を進める中で、Web アプリケーションの変遷について学べる資料に出会いました。

https://speakerdeck.com/recruitengineers/react-2023

こちらの資料を読んだ理由は React の基礎を学びたかったからですが、技術の移り変わりについて非常に丁寧に書いてくださっており、そちらにも興味が湧きました。  
そして以下の流れが見えてきました。

- 2000 年代の**MVC アーキテクチャ**
- 2010 年代の**SPA**
- 現在の**Next.js**

この流れを知った時、ある仮説が浮かびました。

### 仮説: 技術は問題や課題解決の結果として生まれる

**「流行っている技術、新しい技術は、何かの問題を解決した結果として誕生し、普及したのではないか？」**

もしそうなら

- MVC には何か**解決できない問題**が生まれた
- SPA がそれを解決したが、また**別の問題**が生まれた
- Next.js はその問題を解決するために生まれた

この仮説を検証するために、僕は実際に手を動かすことにしました。

**検証方法**
同じブログアプリケーションを、MVC アーキテクチャと Next.js の両方で実装し、具体的な違いを比較します。
僕と同じ初学者、Next.js を何となく使っている、技術選択の理由を知りたい方の参考になれば幸いです。

:::message
記事の内容に誤りや改善点があれば、コメントで教えていただけると嬉しいです。
:::

## 2. 比較検証のアプリケーション紹介

### MVC ブログアプリの概要

まず、2000 年代の web アプリケーションを体験するために、MVC アーキテクチャでブログアプリを作成しました。  
このアプリケーションは、記事の投稿・閲覧・編集・削除ができるシンプルなブログです。あえて jQuery や EJS といった古い技術を使うことで、当時の開発スタイルを再現しています。

https://github.com/takeshi0518/blog-mvc

![MVCブログアプリのスクリーンショット](/images/blog_mvc-screen-shot.png)

#### 技術スタック

- バックエンド: Node.js (Express)
- テンプレートエンジン: EJS
- データベース: PostgreSQL
- フロントエンド: jQuery

#### 実装した機能

- 記事の CRUD 操作(作成・閲覧・編集・削除)

#### アーキテクチャの特徴

MVC アーキテクチャ最大の特徴は**関心の分離(Separation of Concerns)**です。

- Model: データとビジネスロジック
- View: 表示(UI)
- Controller: 制御(リクエストの処理と Model と View の橋渡し)

この３つの役割を分離することで、保守性・再利用性・拡張性・開発効率を高めることができます。

#### 実際のコード

例えば、記事一覧を表示する処理は以下のように分離されています。

**Model (Post.js)** - データ取得に専念

```javascript
  static async findAll() {
    try {
      const result = await pool.query(
        'SELECT * FROM posts ORDER BY created_at DESC'
      );
      return result.rows;
    } catch (err) {
      throw err;
    }
  }
```

**Controller (postsController.js)** - 制御に専念

```javascript
exports.index = async (req, res) => {
  const posts = await Post.findAll(); // Modelに「データくれ」と依頼
  res.render('posts/index', {
    // Viewに「これ表示して」と渡す
    title: '記事一覧',
    posts: posts,
  });
};
```

**View (index.ejs)** - 表示に専念

```html
<% posts.forEach((post) => { %>
<article class="post-card">
  <h2><a href="/posts/<%= post.id %>"><%= post.title %></a></h2>
  <p><%= post.content.substring(0, 100) %>...</p>
</article>
<% }); %>
```

それぞれが独立しているため、例えば

- データベースを変更したい → **Model だけ修正**
- 表示デザインを変更したい → **View だけ修正**
- ページネーションを追加したい → **Controller だけ修正**

このように**影響範囲を限定できる**のが MVC の強みです。

## 3. MVC アーキテクチャの課題

MVC は保守性・拡張性に優れたアーキテクチャですが、モダンな Web アプリケーションに求められる要件を満たすには限界がありました。

### 1. インタラクティブな操作が困難

例えば、「削除ボタンを押した瞬間、即座に記事がリストから消える」といった**楽観的 UI**を実装しようとすると

```html
<form action="/posts/<%= post.id %>?_method=DELETE" method="POST">
  <button type="submit">削除</button>
</form>
```

現状の MVC では**悲観的 UI**

1. ボタンを押す
2. サーバーに POST リクエスト
3. サーバーが DB 変更後、HTML 全体を再生成
4. ページ全体がリロード
5. やっと記事が消える

jQuery で Ajax を使えば部分的な更新も可能ですが、 DOM 操作が複雑になり、バグの温床になります。
EJS などのテンプレートエンジンは**状態を持てない**ため、クライアント側でのデータ管理が困難です。

### 2. フロントエンド/バックエンドの分離による課題

さらに、当時の開発では**バックエンドとフロントエンドが完全に分離**されていました。

**バックエンド(サーバー)** EJS で HTML 構造を生成

```html
<article class="post-card">
  <h2><%= post.title %></h2>
</article>
```

**フロントエンド(ブラウザ)** jQuery で DOM 操作

```javascript
$('.post-card').fadeOut();
```

この分離により、おそらく以下のような課題があったと考えられます

- HTML のクラス名やレイアウト変更のたび、バックエンド/フロントエンド間でコミュニケーションが必要
- セレクタの不一致によるバグが発生しやすい
- UI とロジックが別ファイルで管理され、保守が困難

一方現代の React などの**宣言的 UI**では

```jsx
function PostCard({ post, onDelete }) {
  return (
    <article>
      <h2>{post.title}</h2>
      <button onClick={() => onDelete(post.id)}>削除</button>
    </article>
  );
}
```

UI とロジックが同じコンポーネント内に存在するため、変更の影響範囲が明確で保守性が向上します。

### 3. ページ全体のリロード

MVC では、画面遷移のたびに**ページ全体がリロード**されます。

例えば、記事一覧から詳細画面へ移動する場合

```html
<a href="/posts/<%= post.id %>"><%= post.title %></a>
```

この遷移で起こること

1. サーバーにリクエスト
2. **ヘッダー・フッター・ナビゲーションを含む全ての HTML**を再生成
3. ブラウザが全ての HTML を再描画
4. CSS や JavaScript も再読み込み

**問題点**

- 画面のチラつき（一瞬白くなる）
- 変わらない部分（ヘッダー/フッター）も毎回再描画
- 不要な通信とレンダリングコストが発生

**モダンなフレームワーク(React/Next.js)では**

- 変更された部分だけ再レンダリング
- ヘッダー・フッターはそのまま維持
- スムーズな画面遷移（チラつきなし）
- 最小限の通信で高速表示

この違いが、ユーザー体験の向上に直結します。

## 4. SPA の登場とその課題

### SPA が解決した問題

2010 年代、React・Vue・Angular などの登場により、**SPA(Single Page Application)**が主流になりました。  
SPA は、MVC アーキテクチャの３つの課題をどのように解決したのでしょうか？

### 1. クライアント側での状態管理 → 楽観的 UI の実現

MVC では不可能だった楽観的 UI が、SPA では簡単に実現できるようになりました。

```jsx
//Reactの例
const [posts, setPosts] = useState([]);

const handleDelete = (id) => {
  setPosts(posts.filter((post) => post.id !== id)); //①即座にUI更新
  api.delete(`/posts/${id}`); //②バックグラウンドでサーバー通信
};
```

**MVC との違い**

- **MVC**: サーバーの DB 更新を待ってから、ページ全体をリロードして表示
- **SPA**: ブラウザ上の状態を先に更新し、サーバー通信は後回し

これにより、ユーザーは待たされることがないので、ユーザー体験が向上します。

:::message
ただし、決済や重要なデータ削除など、失敗が許されないアクションでは、依然として悲観的 UI(サーバーの応答を待つ)が適切です。
:::

#### 2. 宣言的 UI → UI とロジックの統合

バックエンド(EJS)とフロントエンド(jQuery)の分離による問題も解決されました。

```jsx
function PostCard({ post, onDelete }) {
  return (
    {post.title}
    <button onClick={() => onDelete(post.id)}>削除</button>
  )
}
```

**宣言的 UI とは**

- **命令的(jQuery)**: 「どのように」実現するかを手順で喜寿
- **宣言的(React)**: 「どうあるべきか」を宣言するだけ

**MVC との違い**

- **MVC**: EJS で HTML 生成 → jQuery で操作(2 箇所を修正)
- **SPA**: １つのコンポーネントに完結(1 箇所のみ修正)

:::message
ここで興味深いのは、**「関心の分離」の考え方が変わった**ことです。
時代によって意味が変わったというのは凄いことだと思います。

**MVC 時代**→ 技術で分離(HTML/CSS/JS)  
**React 時代**→ 機能で分離(コンポーネント単位)

これはパラダイムシフトと言えます。
:::

- UI とロジックが同じコンポーネント内に存在
- クラス名の変更がすぐに分かる
- バックエンド/フロントエンド間のコミュニケーションコスト削減

#### 3. 部分的な再レンダリング → スムーズな画面遷移

ページ全体のリロードも不要になりました。

```jsx
function App() {
  return (
    <>
      <Header /> {/* 変更なし→再レンダリングされない */}
      <PostList props={posts} /> {/* ここだけ更新 */}
      <Footer /> {/* 変更なし→再レンダリングされない */}
    </>
  );
}
```

**React の仮想 DOM による差分検出**

React は内部で仮想 DOM として状態を保持しており、状態が変更された際に差分を計算します。変更があった部分だけを実際の DOM に反映するため、無駄な再レンダリングを避けることができます。

**MVC との違い**

- **MVC**: `/posts` → `/posts/1` へ遷移時、サーバーに全 HTML を再リクエスト
- **SPA**: 初回アクセス時に JavaScript をダウンロード済み。画面遷移はブラウザ上で完結

**クライアントサイドルーティング**

SPA では、URL とコンポーネントがマッピングされています。(React Router など)。サーバーへのリクエストなしに、ブラウザ上でルーティングを処理できます。

- 変更部分だけ更新
- ヘッダー・フッターはそのまま
- チラつきのないスムーズな画面遷移

### しかし、新たな問題も....

SPA は MVC の課題を解決しましたが、新たな問題も生まれました。

#### 1. SEO の問題

SPA では、サーバーから**ほぼ空の HTML**が返ってきます。

```html
<!DOCTYPE html>
<html>
  <head>
    <title>My Blog</title>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>
```

JavaScript が実行されて初めて`<div id="root">`内にコンテンツが生成されます。

**問題点**
検索エンジンのクローラーがこの HTML を見ても

- 記事のタイトルが見えない
- 記事の本文が見えない
- 記事ごとのメタタグ(description)が見えない

**MVC との違い**

- **MVC** サーバーが完成した HTML を返す → クローラーが内容を認識
- **SPA** 空の HTML を返す → クローラーが内容を認識できない

**結果**

- 検索結果に表示されない
- 検索順位が下がる
- SNS でシェアされても適切なプレビューが表示されない

このため、SPA は

- 社内ツール向き。管理画面など(SEO 不要)
- 企業サイト、ブログ、EC サイトなどは不向き。(SEO 必須)

という使い分けが必要になりました。

#### 2. 初回ロードの遅さ

SPA では、初回アクセス時に**すべての JavaScript**をダウンロードする必要があります。

**SPA の初回ロードの流れ:**

```
ユーザーがアクセス
  ↓
① 空のHTMLが届く (数KB)
  ↓
② bundle.jsをダウンロード (数MB)
  ↓
③ JavaScriptを実行・解析
  ↓
④ APIでデータ取得
  ↓
やっと画面表示
```

**MVC との比較**

- **MVC**: 完成した HTML が届く → 即表示
- **SPA**: HTML → JS → 実行 → API → 表示

**問題点:**

bundle.js には、アプリ全体のコードが含まれています:

- トップページのコード
- 記事詳細ページのコード
- 記事編集ページのコード
- すべてのライブラリ(React、React Router 等)

しかし、**トップページを見るだけなら、他のページのコードは不要**です。

**結果**

- 初回ロードが遅い
- ユーザーが待たされる
- 離脱率の増加

:::message
Code Splitting(コード分割)などの最適化手法はありますが、手動での設定が必要でした。
:::

#### 3. JavaScript への依存

SPA は、JavaScript がなければ**何も表示されません**。

**JavaScript が動かない状況**

- JavaScript の読み込みエラー(ネットワーク問題)
- 古いブラウザ(非対応)
- ユーザーが意図的に無効化

**MVC との違い**

- **MVC**: サーバーが完成した HTML を返す → JavaScript 不要でも表示可能
- **SPA**: 空の HTML を返す → JavaScript 必須

**アクセシビリティへの影響**

- スクリーンリーダーでの利用が困難
- 低スペック端末での表示が遅い
- 通信環境が悪い場所でアクセスできない

Web の基本原則である**プログレッシブエンハンスメント**(基本は HTML で提供し、JS で拡張)から外れており、これは許容できない問題でした。

## 5. Next.js での再実装

### Next.js ブログアプリの概要

MVC ブログアプリと同じ機能を、Next.js で再実装しました。

https://github.com/takeshi0518/blog-nextjs

![MVCブログアプリのスクリーンショット](/images/blog-nextjs-screen-shot.png)

#### 技術スタック

- フレームワーク: Next.js 16 (App Router)
- 言語: TypeScript
- データベース: Supabase (PostgreSQL)
- スタイリング: Tailwind CSS

#### 実装した機能

- 記事の CRUD 操作(作成・閲覧・編集・削除)

#### アーキテクチャの特徴

(MVC との違いを説明)

#### 実際のコード例

(記事一覧、作成、削除などのコード)

# 参考にした記事

この記事を書く上で、以下の記事を参考にさせていただきました。

https://qiita.com/SFITB/items/71b81c2ecd8433af64c9

https://qiita.com/os1ma/items/7a229585ebdd8b7d86c2

https://zenn.dev/sc30gsw/articles/aeca93599ce0bb
